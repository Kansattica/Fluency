<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Execution</name>
    </assembly>
    <members>
        <member name="T:Fluency.Common.FluencyType">
            <summary>
            The type a value can have.
            </summary>
        </member>
        <member name="F:Fluency.Common.FluencyType.Bool">
            <summary>
            Represents a boolean (true or false)
            </summary>
        </member>
        <member name="F:Fluency.Common.FluencyType.Int">
            <summary>
            Represents an integer.
            </summary>
        </member>
        <member name="F:Fluency.Common.FluencyType.Double">
            <summary>
            Represents a double precision floating point number.
            </summary>
        </member>
        <member name="F:Fluency.Common.FluencyType.String">
            <summary>
            Represents a string.
            </summary>
        </member>
        <member name="F:Fluency.Common.FluencyType.Function">
            <summary>
            Represents the name of a function.
            </summary>
        </member>
        <member name="F:Fluency.Common.FluencyType.Any">
            <summary>
            Any type, or no type at all. Usually found in function definitions.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Extensions.ExecutionExtensions">
            <summary>
            Extension methods to help execution.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Extensions.ExecutionExtensions.Is``1(Fluency.Execution.Functions.IFunction,System.String)">
            <summary>
            Asserts that this IFunction also implements interface T, usually one of the I[Top|Bottom][InOut] interfaces.
            </summary>
            <param name="function"></param>
            <param name="extraInfo">Will be added to the exception, if thrown.</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:Fluency.Execution.Exceptions.ExecutionException">Thrown if function is not a T</exception>
        </member>
        <member name="M:Fluency.Execution.Extensions.ExecutionExtensions.EnqueueRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Puts everything in range into the queue.
            </summary>
            <param name="queue"></param>
            <param name="range"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluency.Execution.Extensions.ExecutionExtensions.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)">
            <summary>
            Try to get a value from queue. Returns true if it found one.
            </summary>
            <param name="queue"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Com">
            <summary>
            A Fluency source code comment. Passes input to output.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Comment">
            <summary>
            A Fluency source code comment. Passes input to output. Same as <see cref="T:Fluency.Execution.Functions.BuiltIn.Com"/>
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.I">
            <summary>
            The identity function. Passes input to output. Same as <see cref="T:Fluency.Execution.Functions.BuiltIn.Com"/>
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Const">
            <summary>
            Returns an infinite stream of its arguments.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Drain">
            <summary>
            Takes all values from both inputs and returns nothing.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Dup">
            <summary>
            Reads a value from the top input and puts it on both top and bottom outputs.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.First">
            <summary>
            Returns the first N values, then stops.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.MergeTop">
            <summary>
            Pass everything from the top input to the top output, then everything from the bottom input to top output.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.MergeBottom">
            <summary>
            Pass everything from the bottom input to the top output, then everything from the top input to top output.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.SwitchIn">
            <summary>
            If SwitchIn(true), put everything from the top input onto the top pipeline.
            If SwitchIn(false), put everything from the bottom input onto the top pipeline.
            If no argument given, treat the first value seen as if it was passed as the argument.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.SwitchOut">
            <summary>
            If SwitchOut(true), put everything from the top input onto the top pipeline.
            If SwitchOut(false), put everything from the top input onto the bottom pipeline.
            If no argument given, treat the first value seen as if it was passed as the argument.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Unzip">
            <summary>
            If Unzip(true), put an element from the top pipeline onto the top pipeline, then top to bottom, then top to top, and so on.
            If Unzip(false), same, but put on the bottom pipeline first.
            If no argument given, treat the first value seen as if it was passed as the argument.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.WrapBinary`3">
            <summary>
            Wrap a C# function that takes two arguments and returns one value as a Fluency function.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.WrapBinaryStreamOutput`3">
            <summary>
            Wrap a C# function that takes two arguments and returns many values as a Fluency function.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.WrapBinaryTwoOutputs`4">
            <summary>
            Wrap a C# function that takes two arguments and returns one value as a Fluency function.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.WrapUnary`2">
            <summary>
            Wrap a C# function that takes one argument and returns one value as a Fluency function.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.BuiltIn.Zip">
            <summary>
            If Zip(true), put an element from the top pipeline onto the top pipeline, then bottom to top, then top to top, and so on.
            If Zip(false), same, but take from the bottom pipeline first.
            If no argument given, treat the first value seen as if it was passed as the argument.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.IFunction">
            <summary>
            A Fluency function.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Functions.IFunction.Name">
            <summary>
            The function's name.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.ITopOut">
            <summary>
            A Fluency function that writes to the top output.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Functions.ITopOut.Top">
            <summary>
            Called when the function after this one on top wants a value.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.IBottomOut">
            <summary>
            A Fluency function that writes to the bottom output.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Functions.IBottomOut.Bottom">
            <summary>
            Called when the function after this one on the bottom wants a value.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.ITopIn">
            <summary>
            A Fluency function that reads from the top input.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Functions.ITopIn.TopInput">
            <summary>
            A function to call when you want the next value from the top input.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.IBottomIn">
            <summary>
            A Fluency function that reads from the bottom input.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Functions.IBottomIn.BottomInput">
            <summary>
            A function to call when you want the next value from the bottom input.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.GetNext">
            <summary>
            A function that, when called, returns the next element in the corresponding pipeline.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.UserFunctionStub">
            <summary>
            User-defined functions should "expand" on first use so you can do recursion without overflowing the stack.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Functions.Value">
            <summary>
            Represents a value that Fluency functions operate on.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Functions.Value.Done">
            <summary>
            Returned when the called function has no more work to do.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Functions.Value.Type">
            <summary>
            The type of this value.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Functions.Value.#ctor(Fluency.Execution.Parsing.Entities.Argument)">
            <summary>
            Construct a value from a parsed function argument.
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:Fluency.Execution.Functions.Value.Get``1(System.Nullable{Fluency.Common.FluencyType},System.String)">
            <summary>
            Get the value inside the type.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Functions.Value.#ctor(System.Object,Fluency.Common.FluencyType)">
            <summary>
            Construct a value from a C# value and a type.
            </summary>
            <param name="value"></param>
            <param name="type"></param>
        </member>
        <member name="M:Fluency.Execution.Functions.Value.op_Implicit(Fluency.Execution.Functions.Value)~System.Boolean">
            <summary>
            The Done value converts to false, all others to true. This is so you can do something like (while (NextValue()) { doSomething(); }
            </summary>
        </member>
        <member name="P:Fluency.Execution.Functions.Value.Finished">
            <summary>
            The "done" Value that indicates there's no more work.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Functions.Value.Equals(Fluency.Execution.Functions.Value)">
            <summary>
            Two Values are equal if and only if:
            - they are both Done OR
            - neither of them are done AND they have the same type and value.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.IFunctionResolver">
            <summary>
            Something that knows how to make a Fluency function, given a name and arguments.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Interpreter">
            <summary>
            Executes function graphs.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Interpreter.#ctor(Fluency.Execution.Parsing.Parser)">
            <summary>
            Create a new interpreter using the specified parser.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Interpreter.Execute(System.Collections.Generic.IEnumerable{System.String},Fluency.Execution.Functions.GetNext)">
            <summary>
            Execute the program represented by a bunch of lines of source code.
            </summary>
            <param name="program"></param>
            <param name="input">The values to pass to the program.</param>
        </member>
        <member name="T:Fluency.Execution.Linker">
            <summary>
            Ensures all the function names in the program correspond to something.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Linker.Register(System.String,Fluency.Execution.FunctionMaker)">
            <summary>
            Tell the linker about a function.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Linker.Resolve(System.String,Fluency.Execution.Functions.Value[])">
            <summary>
            Create a new instance of the function with the specified name.
            </summary>
            <param name="name"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.Argument">
            <summary>
            Represents a parsed function argument.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.Argument.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Argument.#ctor">
            <summary>
            Make an empty argument.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Argument.TryParse(System.String,Fluency.Execution.Parsing.Entities.Argument@)">
            <summary>
            Create a new parsed argument from a string representing one.
            Valid arguments are "strings", integers, floating point numbers, and function names. 
            The special argument ... (three periods) is also valid in a Def only.
            </summary>
            <param name="arg">The string to be parsed.</param>
            <param name="argument">The parsed result, if successful.</param>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Argument.GetAs``1">
            <summary>
            Attempt to return this function's value as a type T.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Argument.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.ArgumentTypes.BoolArg">
            <summary>
            Represents a boolean argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.BoolArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.BoolArg.TryParseArg(System.String)">
            <summary>
            If str represents a bool, make a BoolArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.BoolArg.ToString">
            <summary>
            Return the stored bool as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.BoolArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.ArgumentTypes.DoubleArg">
            <summary>
            Represents a double argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.DoubleArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.DoubleArg.TryParseArg(System.String)">
            <summary>
            If str represents a double, make a DoubleArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.DoubleArg.ToString">
            <summary>
            Return the stored double as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.DoubleArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg">
            <summary>
            Represents a function argument to any function or a parameter a declared function takes.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg.DeclaredType">
            <summary>
            If this is a declaration of a parameter, what type is it
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg.FunctionName">
            <summary>
            The name of the function or parameter this instance represents.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg.TryParseArg(System.String)">
            <summary>
            If str represents a function name (no quotes, letters only), make a FuncArg. Otherwise, return null.
            In a declaration, function names can have a type, such as int n.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg.ToString">
            <summary>
            Return the stored function name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.FunctionArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.ArgumentTypes.IntArg">
            <summary>
            Represents an integer argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.IntArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.IntArg.TryParseArg(System.String)">
            <summary>
            If str represents an integer, make an IntArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.IntArg.ToString">
            <summary>
            Return the stored integer as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.IntArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.ArgumentTypes.StringArg">
            <summary>
            Represents a string argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.ArgumentTypes.StringArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.StringArg.TryParseArg(System.String)">
            <summary>
            If str represents a string (surrounded by quotes), make a StringArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.StringArg.ToString">
            <summary>
            Return the stored string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.ArgumentTypes.StringArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionGraph">
            <summary>
            Represents a single user-defined function and all the functions that implement it.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionGraph.Head">
            <summary>
            The root node of the function. This is the Def() function.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionGraph.Name">
            <summary>
            Name of the function this graph represents.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionGraph.Arguments">
            <summary>
            The arguments this function has declared.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionGraph.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Fluency.Execution.Parsing.Entities.FunctionToken}})">
            <summary>
            Create a new function graph. This takes an IEnumerable of tokenized lines (which are themselves IEnumerables of tokens).
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode">
            <summary>
            Represents a single function in a pipeline.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.Name">
            <summary>
            The function's name.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.Arguments">
            <summary>
            The function's declared arguments.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.TopIn">
            <summary>
            The function that this reads from on top ("top" can be above or immediately before on the same level).
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.BottomIn">
            <summary>
            The function that feeds this one from the bottom.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.TopOut">
            <summary>
            The function that this outputs to on top ("top" can be above or immediately before on the same level).
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.BottomOut">
            <summary>
            The function that this outputs to on the bottom.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.Tiebreaker">
            <summary>
            In the case where there are multiple outgoing bottom pipelines, the one that's furthest to the right wins.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.Id">
            <summary>
            A unique integer ID for this function. Two function calls with the same name have different IDs.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.#ctor(Fluency.Execution.Parsing.Entities.FunctionToken)">
            <summary>
            Make a function node from a parsed function token.
            </summary>
            <param name="tok"></param>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.FunctionGraph.FunctionNode.ToString">
            <summary>
            Return a string that looks like Name(arguments, like this)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.FunctionToken">
            <summary>
            Represents a parsed function from source control.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.Name">
            <summary>
            The function's name.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.Arguments">
            <summary>
            The arguments the function takes.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.Line">
            <summary>
            The line number this function was on. Not available when constructed, has to be set from the outside for better metadata and error location.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.Range">
            <summary>
            The inclusive range of indexes this was in its original line.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.Original">
            <summary>
            What the function looked like before it got spaces, periods, and slashes trimmed.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.ConnectsUpBefore">
            <summary>
            Whether the function connects to the one above it for input (starts with \.)
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.ConnectsBefore">
            <summary>
            Whether the function connects to the one before it (starts with .)
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.FunctionToken.ConnectsUpAfter">
            <summary>
            Whether the function connects to the one above it for output (ends with ./)
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.FunctionToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Create a new function token.
            </summary>
            <param name="toparse"></param>
            <param name="start">The first index into the line containing this function.</param>
            <param name="end">The last index into the line containing this function.</param>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.FunctionToken.ToString">
            <summary>
            Prettyprints some metadata about the function token.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.Line">
            <summary>
            Represents a raw line from the source file.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.Line.Number">
            <summary>
            The one-indexed line number.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.Line.Contents">
            <summary>
            The contents of the string.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Line.Create(System.String,System.Int32)">
            <summary>
            Create a line. This is a factory function so you can give it to Linq's .Select and have it do the indexing for you.
            </summary>
            <param name="contents"></param>
            <param name="number">The zero-based index. The number one higher than this will be stored.</param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Line.ToString">
            <summary>
            Return lineNumber: Contents
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Entities.Range">
            <summary>
            Represents an inclusive range.
            </summary>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.Range.Min">
            <summary>
            The lower bound.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Execution.Parsing.Entities.Range.Max">
            <summary>
            The upper bound.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new range from its inclusive bounds.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if min is greater than max.</exception>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.Contains(System.Int32)">
            <summary>
            Whether n is inside the range.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.Equals(Fluency.Execution.Parsing.Entities.Range)">
            <summary>
            Two ranges are equal if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.Equals(System.Object)">
            <summary>
            Two ranges are equal if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.GetHashCode">
            <summary>
            Gets a hash code by xoring the min and max's hash codes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.op_Equality(Fluency.Execution.Parsing.Entities.Range,Fluency.Execution.Parsing.Entities.Range)">
            <summary>
            Two ranges are equal if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.op_Inequality(Fluency.Execution.Parsing.Entities.Range,Fluency.Execution.Parsing.Entities.Range)">
            <summary>
            Two ranges are equal if and only if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.op_Implicit(System.ValueTuple{System.Int32,System.Int32})~Fluency.Execution.Parsing.Entities.Range">
            <summary>
            A Range can be implicitly constructed from a tuple of two ints. 
            </summary>
            <param name="pair"></param>
        </member>
        <member name="M:Fluency.Execution.Parsing.Entities.Range.ToString">
            <summary>
            Returns a nice string representation like (Min, Max)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Exceptions.ParseException">
            <summary>
             Represents an error that ocurred while parsing the source code.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Parsing.ParseExtensions">
            <summary>
            A collection of extension methods to help with parsing.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Parsing.ParseExtensions.Stringify(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Turn an IEnumerable of chars into a string.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.ParseExtensions.Stringify(System.Collections.Generic.IEnumerable{Fluency.Execution.Parsing.Entities.Argument})">
            <summary>
            Prettyprint an array of Arguments, with a comma and space between each one.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.ParseExtensions.SkipBetween``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
            <summary>
            Return elements from source until startPredicate returns true, then skip them until endPredicate returns true.
            Note that the element endPredicate returns true for will be returned.
            </summary>
            <param name="source"></param>
            <param name="startPredicate">When this returns true, begin skipping elements.</param>
            <param name="endPredicate">When this returns true, stop skipping elements and yield the current one.</param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.ParseExtensions.MergeLastIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``0,``0})">
            <summary>
            Call predicate on each element. If that predicate returns true, then call merge on the current and previous elements and yield that instead of either the current or previous element.
            </summary>
            <param name="source"></param>
            <param name="predicate">If this is true for current, call merge(current, previous)</param>
            <param name="merge">If predicate(current) is true, yield merge(current, previous) instead of current or previous.</param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.ParseExtensions.GroupWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean,Fluency.Execution.Parsing.GroupWhileAction})">
            <summary>
            Groups elements according to pickAction. For each element, pickAction is called with the element and whether the function is currently making a group.
            Groups will be yielded when complete- that is, when pickAction returns <see cref="F:Fluency.Execution.Parsing.GroupWhileAction.LeaveExclude"/> or <see cref="F:Fluency.Execution.Parsing.GroupWhileAction.LeaveInclude"/>.
            </summary>
            <param name="source"></param>
            <param name="pickAction"></param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Execution.Parsing.ParseExtensions.GroupUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Gather elements of source into a group while predicate returns false. If predicate returns true, finish the current group and start a new one.
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="inclusive">If true, the element that caused predicate to return false will be put in the current group. Otherwise, it'll be in the next one.</param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.Grouped`1">
            <summary>
            Represents a group of elements from <see cref="M:Fluency.Execution.Parsing.ParseExtensions.GroupUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Boolean)" /> or <see cref="M:Fluency.Execution.Parsing.ParseExtensions.GroupWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean,Fluency.Execution.Parsing.GroupWhileAction})"/>.
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="P:Fluency.Execution.Parsing.Grouped`1.Indexes">
            <summary>
            The inclusive range of indexes this group was taken from.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Execution.Parsing.Grouped`1.#ctor(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Construct a new group.
            </summary>
            <param name="source"></param>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
        </member>
        <member name="T:Fluency.Execution.Parsing.GroupWhileAction">
            <summary>
            Actions you can instruct <see cref="M:Fluency.Execution.Parsing.ParseExtensions.GroupWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean,Fluency.Execution.Parsing.GroupWhileAction})"/> to take from its callback.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.GroupWhileAction.In">
            <summary>
            Add the current item into the group, starting a new one if necessary.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.GroupWhileAction.StillOut">
            <summary>
            We're not making a group, and this element should stay out of the group. Only return this if pickAction was passed false.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.GroupWhileAction.LeaveInclude">
            <summary>
            Finish the current group and put this item in it.
            </summary>
        </member>
        <member name="F:Fluency.Execution.Parsing.GroupWhileAction.LeaveExclude">
            <summary>
            Finish the current group and don't put this item in it.
            </summary>
        </member>
        <member name="T:Fluency.Execution.Parsing.Parser">
            <summary>
            Represents a Fluency parser.
            </summary>
        </member>
        <member name="M:Fluency.Execution.Parsing.Parser.#ctor(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Construct a new parser.
            </summary>
            <param name="verbose">Be verbose.</param>
            <param name="tabWarn">Whether to warn about tabs after text.</param>
            <param name="tabWidth">How wide to try to expand tabs to.</param>
        </member>
        <member name="M:Fluency.Execution.Parsing.Parser.Parse(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parse an IEnumerable of lines, such as those from File.ReadAllLines.
            </summary>
            <param name="lines"></param>
            <returns></returns>
        </member>
        <member name="T:Fluency.Execution.Parsing.ParsedCallback">
            <summary>
            Called on each parsed function after it's parsed successfully for anyone that wants to see. 
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
    </members>
</doc>
