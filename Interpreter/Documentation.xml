<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Interpreter</name>
    </assembly>
    <members>
        <member name="T:Fluency.Interpreter.Execution.Interpreter">
            <summary>
            Executes function graphs.
            </summary>
        </member>
        <member name="M:Fluency.Interpreter.Execution.Interpreter.#ctor(Fluency.Interpreter.Parsing.Parser)">
            <summary>
            Create a new interpreter using the specified parser.
            </summary>
        </member>
        <member name="M:Fluency.Interpreter.Execution.Interpreter.Execute(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Execute the program represented by a bunch of lines of source code.
            </summary>
            <param name="program"></param>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.Argument">
            <summary>
            Represents a parsed function argument.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.Argument.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Argument.#ctor">
            <summary>
            Make an empty argument.
            </summary>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Argument.TryParse(System.String,Fluency.Interpreter.Parsing.Entities.Argument@)">
            <summary>
            Create a new parsed argument from a string representing one.
            Valid arguments are "strings", integers, floating point numbers, and function names. 
            The special argument ... (three periods) is also valid in a Def only.
            </summary>
            <param name="arg">The string to be parsed.</param>
            <param name="argument">The parsed result, if successful.</param>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Argument.GetAs``1">
            <summary>
            Attempt to return this function's value as a type T.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Argument.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.ParsedType">
            <summary>
            The parsed type of the argument.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.ParsedType.Int">
            <summary>
            This argument is an integer.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.ParsedType.Double">
            <summary>
            This argument is a double precision floating point number.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.ParsedType.String">
            <summary>
            This argument is a string.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.ParsedType.Function">
            <summary>
            This argument is the name of a function.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.ParsedType.Any">
            <summary>
            When found in Def, indicates that the argument can be of any type.
            </summary>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.DoubleArg">
            <summary>
            Represents a double argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.DoubleArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.DoubleArg.TryParseArg(System.String)">
            <summary>
            If str represents a double, make a DoubleArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.DoubleArg.ToString">
            <summary>
            Return the stored double as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.DoubleArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg">
            <summary>
            Represents a function argument to any function or a parameter a declared function takes.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg.DeclaredType">
            <summary>
            If this is a declaration of a parameter, what type is it
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg.FunctionName">
            <summary>
            The name of the function or parameter this instance represents.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg.TryParseArg(System.String)">
            <summary>
            If str represents a function name (no quotes, letters only), make a FuncArg. Otherwise, return null.
            In a declaration, function names can have a type, such as int n.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg.ToString">
            <summary>
            Return the stored function name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.FunctionArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.IntArg">
            <summary>
            Represents an integer argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.IntArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.IntArg.TryParseArg(System.String)">
            <summary>
            If str represents an integer, make an IntArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.IntArg.ToString">
            <summary>
            Return the stored integer as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.IntArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.StringArg">
            <summary>
            Represents a string argument to a function.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.StringArg.Type">
            <summary>
            The Fluency type this object is.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.StringArg.TryParseArg(System.String)">
            <summary>
            If str represents a string (surrounded by quotes), make a StringArg.  Otherwise, return null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.StringArg.ToString">
            <summary>
            Return the stored string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.ArgumentTypes.StringArg.Value">
            <summary>
            Get the value this argument represents.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionGraph">
            <summary>
            Represents a single user-defined function and all the functions that implement it.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionGraph.Head">
            <summary>
            The root node of the function. This is the Def() function.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionGraph.Name">
            <summary>
            Name of the function this graph represents.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionGraph.Arguments">
            <summary>
            The arguments this function has declared.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionGraph.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Fluency.Interpreter.Parsing.Entities.FunctionToken}})">
            <summary>
            Create a new function graph. This takes an IEnumerable of tokenized lines (which are themselves IEnumerables of tokens).
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode">
            <summary>
            Represents a single function in a pipeline.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.Name">
            <summary>
            The function's name.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.Arguments">
            <summary>
            The function's declared arguments.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.TopIn">
            <summary>
            The function that this reads from on top ("top" can be above or immediately before on the same level).
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.BottomIn">
            <summary>
            The function that feeds this one from the bottom.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.TopOut">
            <summary>
            The function that this outputs to on top ("top" can be above or immediately before on the same level).
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.BottomOut">
            <summary>
            The function that this outputs to on the bottom.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.Id">
            <summary>
            A unique integer ID for this function. Two function calls with the same name have different IDs.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.#ctor(Fluency.Interpreter.Parsing.Entities.FunctionToken)">
            <summary>
            Make a function node from a parsed function token.
            </summary>
            <param name="tok"></param>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.FunctionGraph.FunctionNode.ToString">
            <summary>
            Return a string that looks like Name(arguments, like this)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.FunctionToken">
            <summary>
            Represents a parsed function from source control.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.Name">
            <summary>
            The function's name.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.Arguments">
            <summary>
            The arguments the function takes.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.Line">
            <summary>
            The line number this function was on. Not available when constructed, has to be set from the outside for better metadata and error location.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.Range">
            <summary>
            The inclusive range of indexes this was in its original line.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.Original">
            <summary>
            What the function looked like before it got spaces, periods, and slashes trimmed.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.ConnectsUpBefore">
            <summary>
            Whether the function connects to the one above it for input (starts with \.)
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.ConnectsBefore">
            <summary>
            Whether the function connects to the one before it (starts with .)
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.FunctionToken.ConnectsUpAfter">
            <summary>
            Whether the function connects to the one above it for output (ends with ./)
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.FunctionToken.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Create a new function token.
            </summary>
            <param name="toparse"></param>
            <param name="start">The first index into the line containing this function.</param>
            <param name="end">The last index into the line containing this function.</param>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.FunctionToken.ToString">
            <summary>
            Prettyprints some metadata about the function token.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.Line">
            <summary>
            Represents a raw line from the source file.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.Line.Number">
            <summary>
            The one-indexed line number.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.Line.Contents">
            <summary>
            The contents of the string.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Line.Create(System.String,System.Int32)">
            <summary>
            Create a line. This is a factory function so you can give it to Linq's .Select and have it do the indexing for you.
            </summary>
            <param name="contents"></param>
            <param name="number">The zero-based index. The number one higher than this will be stored.</param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Line.ToString">
            <summary>
            Return lineNumber: Contents
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Entities.Range">
            <summary>
            Represents an inclusive range.
            </summary>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.Range.Min">
            <summary>
            The lower bound.
            </summary>
            <value></value>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Entities.Range.Max">
            <summary>
            The upper bound.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new range from its inclusive bounds.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if min is greater than max.</exception>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.Contains(System.Int32)">
            <summary>
            Whether n is inside the range.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.Equals(Fluency.Interpreter.Parsing.Entities.Range)">
            <summary>
            Two ranges are equal if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.Equals(System.Object)">
            <summary>
            Two ranges are equal if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.GetHashCode">
            <summary>
            Gets a hash code by xoring the min and max's hash codes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.op_Equality(Fluency.Interpreter.Parsing.Entities.Range,Fluency.Interpreter.Parsing.Entities.Range)">
            <summary>
            Two ranges are equal if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.op_Inequality(Fluency.Interpreter.Parsing.Entities.Range,Fluency.Interpreter.Parsing.Entities.Range)">
            <summary>
            Two ranges are equal if and only if they represent the same range- that is, they have the same minimum and maximum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.op_Implicit(System.ValueTuple{System.Int32,System.Int32})~Fluency.Interpreter.Parsing.Entities.Range">
            <summary>
            A Range can be implicitly constructed from a tuple of two ints. 
            </summary>
            <param name="pair"></param>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Entities.Range.ToString">
            <summary>
            Returns a nice string representation like (Min, Max)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.ParseExtensions">
            <summary>
            A collection of extension methods to help with parsing.
            </summary>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.ParseExtensions.Stringify(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Turn an IEnumerable of chars into a string.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.ParseExtensions.Stringify(System.Collections.Generic.IEnumerable{Fluency.Interpreter.Parsing.Entities.Argument})">
            <summary>
            Prettyprint an array of Arguments, with a comma and space between each one.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.ParseExtensions.SkipBetween``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
            <summary>
            Return elements from source until startPredicate returns true, then skip them until endPredicate returns true.
            Note that the element endPredicate returns true for will be returned.
            </summary>
            <param name="source"></param>
            <param name="startPredicate">When this returns true, begin skipping elements.</param>
            <param name="endPredicate">When this returns true, stop skipping elements and yield the current one.</param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.ParseExtensions.MergeLastIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``0,``0})">
            <summary>
            Call predicate on each element. If that predicate returns true, then call merge on the current and previous elements and yield that instead of either the current or previous element.
            </summary>
            <param name="source"></param>
            <param name="predicate">If this is true for current, call merge(current, previous)</param>
            <param name="merge">If predicate(current) is true, yield merge(current, previous) instead of current or previous.</param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.ParseExtensions.GroupWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean,Fluency.Interpreter.Parsing.GroupWhileAction})">
            <summary>
            Groups elements according to pickAction. For each element, pickAction is called with the element and whether the function is currently making a group.
            Groups will be yielded when complete- that is, when pickAction returns <see cref="F:Fluency.Interpreter.Parsing.GroupWhileAction.LeaveExclude"/> or <see cref="F:Fluency.Interpreter.Parsing.GroupWhileAction.LeaveInclude"/>.
            </summary>
            <param name="source"></param>
            <param name="pickAction"></param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.ParseExtensions.GroupUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Gather elements of source into a group while predicate returns false. If predicate returns true, finish the current group and start a new one.
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="inclusive">If true, the element that caused predicate to return false will be put in the current group. Otherwise, it'll be in the next one.</param>
            <typeparam name="TSource"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Grouped`1">
            <summary>
            Represents a group of elements from <see cref="M:Fluency.Interpreter.Parsing.ParseExtensions.GroupUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Boolean)" /> or <see cref="M:Fluency.Interpreter.Parsing.ParseExtensions.GroupWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean,Fluency.Interpreter.Parsing.GroupWhileAction})"/>.
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="P:Fluency.Interpreter.Parsing.Grouped`1.Indexes">
            <summary>
            The inclusive range of indexes this group was taken from.
            </summary>
            <value></value>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Grouped`1.#ctor(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Construct a new group.
            </summary>
            <param name="source"></param>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.GroupWhileAction">
            <summary>
            Actions you can instruct <see cref="M:Fluency.Interpreter.Parsing.ParseExtensions.GroupWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean,Fluency.Interpreter.Parsing.GroupWhileAction})"/> to take from its callback.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.GroupWhileAction.In">
            <summary>
            Add the current item into the group, starting a new one if necessary.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.GroupWhileAction.StillOut">
            <summary>
            We're not making a group, and this element should stay out of the group. Only return this if pickAction was passed false.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.GroupWhileAction.LeaveInclude">
            <summary>
            Finish the current group and put this item in it.
            </summary>
        </member>
        <member name="F:Fluency.Interpreter.Parsing.GroupWhileAction.LeaveExclude">
            <summary>
            Finish the current group and don't put this item in it.
            </summary>
        </member>
        <member name="T:Fluency.Interpreter.Parsing.Parser">
            <summary>
            Represents a Fluency parser.
            </summary>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Parser.#ctor(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Construct a new parser.
            </summary>
            <param name="verbose">Be verbose.</param>
            <param name="tabWarn">Whether to warn about tabs after text.</param>
            <param name="tabWidth">How wide to try to expand tabs to.</param>
        </member>
        <member name="M:Fluency.Interpreter.Parsing.Parser.Parse(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parse an IEnumerable of lines, such as those from File.ReadAllLines.
            </summary>
            <param name="lines"></param>
            <returns></returns>
        </member>
    </members>
</doc>
